{
    "sourceFile": "src/user/controller.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 20,
            "patches": [
                {
                    "date": 1757004156693,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1757004500900,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -764,35 +764,37 @@\n         \n         console.log('DEBUG: State ID:', stateId);\n         console.log('DEBUG: Head offices in state:', headOfficeIds.length);\n         console.log('DEBUG: Head office IDs:', headOfficeIds.map(id => id.toString()));\n-        \n-        // Additional debug: Check some sample users to understand their data structure\n-        const sampleUsers = await User.find({ isActive: true }).limit(5).select('name email headOffice headOffices state');\n-        console.log('DEBUG: Sample users data:');\n-        sampleUsers.forEach(user => {\n-            console.log(`  User: ${user.name}`);\n-            console.log(`    state: ${user.state || 'null'}`);\n-            console.log(`    headOffice: ${user.headOffice || 'null'}`);\n-            console.log(`    headOffices: ${JSON.stringify(user.headOffices || [])}`);\n-        });\n \n         // Build query to find users in this state\n         // Include users who are:\n         // 1. Directly assigned to the state\n-        // 2. Assigned to head offices in this state  \n+        // 2. Assigned to head offices in this state\n+        \n         let query = {\n             isActive: true,\n             $or: [\n                 // Direct state assignment\n                 { state: stateId },\n-                // Head office assignment (by ID)\n+                // Head office assignment (single head office)\n                 { headOffice: { $in: headOfficeIds } },\n+                // Multiple head offices assignment (any head office in the array matches)\n                 { headOffices: { $in: headOfficeIds } }\n             ]\n         };\n         \n-        console.log('DEBUG: Query:', JSON.stringify(query, null, 2));\n+        // Debug: Test individual conditions\n+        const directStateCount = await User.countDocuments({ isActive: true, state: stateId });\n+        const headOfficeCount = await User.countDocuments({ isActive: true, headOffice: { $in: headOfficeIds } });\n+        const headOfficesCount = await User.countDocuments({ isActive: true, headOffices: { $in: headOfficeIds } });\n+        const totalQueryCount = await User.countDocuments(query);\n+        \n+        console.log('DEBUG: Query results:');\n+        console.log('  Direct state assignments:', directStateCount);\n+        console.log('  Single headOffice matches:', headOfficeCount);\n+        console.log('  Multiple headOffices matches:', headOfficesCount);\n+        console.log('  Total query matches:', totalQueryCount);\n \n         // Add search filter if provided\n         if (search) {\n             query.$and = query.$and || [];\n"
                },
                {
                    "date": 1757004683496,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -766,35 +766,46 @@\n         console.log('DEBUG: Head offices in state:', headOfficeIds.length);\n         console.log('DEBUG: Head office IDs:', headOfficeIds.map(id => id.toString()));\n \n         // Build query to find users in this state\n-        // Include users who are:\n-        // 1. Directly assigned to the state\n-        // 2. Assigned to head offices in this state\n+        // Instead of using a complex $or query, let's use separate queries and combine results\n         \n+        const mongoose = require('mongoose');\n+        \n+        // Ensure proper ObjectId conversion\n+        const stateObjectId = mongoose.Types.ObjectId(stateId);\n+        const headOfficeObjectIds = headOfficeIds.map(id => mongoose.Types.ObjectId(id));\n+        \n+        // Find users by different criteria\n+        const directStateUsers = await User.find({ \n+            isActive: true, \n+            state: stateObjectId \n+        }).select('_id');\n+        \n+        const headOfficeUsers = await User.find({ \n+            isActive: true, \n+            headOffice: { $in: headOfficeObjectIds } \n+        }).select('_id');\n+        \n+        const headOfficesUsers = await User.find({ \n+            isActive: true, \n+            headOffices: { $in: headOfficeObjectIds } \n+        }).select('_id');\n+        \n+        // Combine all user IDs and remove duplicates\n+        const allUserIds = new Set();\n+        directStateUsers.forEach(user => allUserIds.add(user._id.toString()));\n+        headOfficeUsers.forEach(user => allUserIds.add(user._id.toString()));\n+        headOfficesUsers.forEach(user => allUserIds.add(user._id.toString()));\n+        \n+        // Convert back to ObjectIds for the final query\n+        const uniqueUserIds = Array.from(allUserIds).map(id => mongoose.Types.ObjectId(id));\n+        \n+        // Build final query using the collected user IDs\n         let query = {\n             isActive: true,\n-            $or: [\n-                // Direct state assignment\n-                { state: stateId },\n-                // Head office assignment (single head office)\n-                { headOffice: { $in: headOfficeIds } },\n-                // Multiple head offices assignment (any head office in the array matches)\n-                { headOffices: { $in: headOfficeIds } }\n-            ]\n+            _id: { $in: uniqueUserIds }\n         };\n-        \n-        // Debug: Test individual conditions\n-        const directStateCount = await User.countDocuments({ isActive: true, state: stateId });\n-        const headOfficeCount = await User.countDocuments({ isActive: true, headOffice: { $in: headOfficeIds } });\n-        const headOfficesCount = await User.countDocuments({ isActive: true, headOffices: { $in: headOfficeIds } });\n-        const totalQueryCount = await User.countDocuments(query);\n-        \n-        console.log('DEBUG: Query results:');\n-        console.log('  Direct state assignments:', directStateCount);\n-        console.log('  Single headOffice matches:', headOfficeCount);\n-        console.log('  Multiple headOffices matches:', headOfficesCount);\n-        console.log('  Total query matches:', totalQueryCount);\n \n         // Add search filter if provided\n         if (search) {\n             query.$and = query.$and || [];\n@@ -891,11 +902,73 @@\n     }\n };\n \n /**\n- * Get current user's assigned head offices\n- * GET /api/users/my-head-offices\n+ * Debug endpoint to test user queries by state\n+ * GET /api/users/debug-by-state\n  */\n+exports.debugUsersByState = async(req, res) => {\n+    try {\n+        const currentUser = req.user;\n+\n+        // Check if the current user is a State Head\n+        if (!currentUser || currentUser.role !== 'State Head') {\n+            return res.status(403).json({\n+                success: false,\n+                message: 'Access denied. Only State Heads can access this endpoint.'\n+            });\n+        }\n+\n+        // Get the current user's state\n+        const stateHeadUser = await User.findById(currentUser.id).populate('state');\n+        \n+        if (!stateHeadUser || !stateHeadUser.state) {\n+            return res.status(400).json({\n+                success: false,\n+                message: 'State Head must be assigned to a state to view users.'\n+            });\n+        }\n+\n+        const stateId = stateHeadUser.state._id;\n+\n+        // Get head offices in the state\n+        const HeadOffice = require('../headoffice/Model');\n+        const headOfficesInState = await HeadOffice.find({ \n+            state: stateId, \n+            isActive: true \n+        }).select('_id name');\n+\n+        const headOfficeIds = headOfficesInState.map(ho => ho._id);\n+        \n+        // Test individual conditions\n+        const directStateUsers = await User.find({ isActive: true, state: stateId }).select('name email headOffice headOffices state');\n+        const headOfficeUsers = await User.find({ isActive: true, headOffice: { $in: headOfficeIds } }).select('name email headOffice headOffices state');\n+        const headOfficesUsers = await User.find({ isActive: true, headOffices: { $in: headOfficeIds } }).select('name email headOffice headOffices state');\n+        \n+        res.json({\n+            success: true,\n+            debug: {\n+                stateId: stateId,\n+                stateName: stateHeadUser.state.name,\n+                headOfficesInState: headOfficesInState,\n+                directStateUsers: directStateUsers,\n+                headOfficeUsers: headOfficeUsers,\n+                headOfficesUsers: headOfficesUsers,\n+                counts: {\n+                    directState: directStateUsers.length,\n+                    headOffice: headOfficeUsers.length,\n+                    headOffices: headOfficesUsers.length\n+                }\n+            }\n+        });\n+    } catch (err) {\n+        console.error('Debug users by state error:', err);\n+        res.status(500).json({\n+            success: false,\n+            message: err.message || 'Server error'\n+        });\n+    }\n+};\n exports.getMyHeadOffices = async(req, res) => {\n     try {\n         const user = await User.findById(req.user.id)\n             .populate('headOffice', 'name code')\n"
                },
                {
                    "date": 1757004696383,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,8 @@\n // controllers/userController.js\n const User = require('./User');\n const bcrypt = require('bcryptjs');\n+const mongoose = require('mongoose');\n \n /**\n  * Get all users with enhanced pagination and search\n  * GET /api/users\n"
                },
                {
                    "date": 1757004711686,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -769,10 +769,8 @@\n \n         // Build query to find users in this state\n         // Instead of using a complex $or query, let's use separate queries and combine results\n         \n-        const mongoose = require('mongoose');\n-        \n         // Ensure proper ObjectId conversion\n         const stateObjectId = mongoose.Types.ObjectId(stateId);\n         const headOfficeObjectIds = headOfficeIds.map(id => mongoose.Types.ObjectId(id));\n         \n"
                },
                {
                    "date": 1757004838175,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -767,43 +767,22 @@\n         console.log('DEBUG: Head offices in state:', headOfficeIds.length);\n         console.log('DEBUG: Head office IDs:', headOfficeIds.map(id => id.toString()));\n \n         // Build query to find users in this state\n-        // Instead of using a complex $or query, let's use separate queries and combine results\n+        // Include users who are:\n+        // 1. Directly assigned to the state\n+        // 2. Assigned to head offices in this state\n         \n-        // Ensure proper ObjectId conversion\n-        const stateObjectId = mongoose.Types.ObjectId(stateId);\n-        const headOfficeObjectIds = headOfficeIds.map(id => mongoose.Types.ObjectId(id));\n-        \n-        // Find users by different criteria\n-        const directStateUsers = await User.find({ \n-            isActive: true, \n-            state: stateObjectId \n-        }).select('_id');\n-        \n-        const headOfficeUsers = await User.find({ \n-            isActive: true, \n-            headOffice: { $in: headOfficeObjectIds } \n-        }).select('_id');\n-        \n-        const headOfficesUsers = await User.find({ \n-            isActive: true, \n-            headOffices: { $in: headOfficeObjectIds } \n-        }).select('_id');\n-        \n-        // Combine all user IDs and remove duplicates\n-        const allUserIds = new Set();\n-        directStateUsers.forEach(user => allUserIds.add(user._id.toString()));\n-        headOfficeUsers.forEach(user => allUserIds.add(user._id.toString()));\n-        headOfficesUsers.forEach(user => allUserIds.add(user._id.toString()));\n-        \n-        // Convert back to ObjectIds for the final query\n-        const uniqueUserIds = Array.from(allUserIds).map(id => mongoose.Types.ObjectId(id));\n-        \n-        // Build final query using the collected user IDs\n         let query = {\n             isActive: true,\n-            _id: { $in: uniqueUserIds }\n+            $or: [\n+                // Direct state assignment\n+                { state: stateId },\n+                // Head office assignment (single head office)\n+                { headOffice: { $in: headOfficeIds } },\n+                // Multiple head offices assignment\n+                { headOffices: { $in: headOfficeIds } }\n+            ]\n         };\n \n         // Add search filter if provided\n         if (search) {\n"
                },
                {
                    "date": 1757004906277,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -765,8 +765,20 @@\n         \n         console.log('DEBUG: State ID:', stateId);\n         console.log('DEBUG: Head offices in state:', headOfficeIds.length);\n         console.log('DEBUG: Head office IDs:', headOfficeIds.map(id => id.toString()));\n+        \n+        // Debug: Test if Darbhanga is in the list\n+        const darbhangaId = '68a42d720fd473dd1c3074d3';\n+        const isDarbhangaIncluded = headOfficeIds.some(id => id.toString() === darbhangaId);\n+        console.log('DEBUG: Is Darbhanga included?', isDarbhangaIncluded);\n+        \n+        // Debug: Count users with Darbhanga head office\n+        const darbhangaCount = await User.countDocuments({ \n+            isActive: true, \n+            headOffice: darbhangaId \n+        });\n+        console.log('DEBUG: Users with Darbhanga headOffice:', darbhangaCount);\n \n         // Build query to find users in this state\n         // Include users who are:\n         // 1. Directly assigned to the state\n"
                },
                {
                    "date": 1757005282871,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -777,8 +777,29 @@\n             isActive: true, \n             headOffice: darbhangaId \n         });\n         console.log('DEBUG: Users with Darbhanga headOffice:', darbhangaCount);\n+        \n+        // Debug: Get all users with Darbhanga head office to see why they're not matching\n+        const darbhangaUsers = await User.find({ \n+            isActive: true, \n+            headOffice: darbhangaId \n+        }).select('name email headOffice headOffices');\n+        console.log('DEBUG: Darbhanga users found:', darbhangaUsers.map(u => ({ \n+            name: u.name, \n+            email: u.email, \n+            headOffice: u.headOffice?.toString(), \n+            headOffices: u.headOffices \n+        })));\n+        \n+        // Debug: Test the exact query condition for headOffice field\n+        const headOfficeQuery = { isActive: true, headOffice: { $in: headOfficeIds } };\n+        const headOfficeMatches = await User.find(headOfficeQuery).select('name email headOffice');\n+        console.log('DEBUG: Users matching headOffice $in query:', headOfficeMatches.map(u => ({ \n+            name: u.name, \n+            email: u.email, \n+            headOffice: u.headOffice?.toString() \n+        })));\n \n         // Build query to find users in this state\n         // Include users who are:\n         // 1. Directly assigned to the state\n"
                },
                {
                    "date": 1757005402258,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -798,8 +798,22 @@\n             name: u.name, \n             email: u.email, \n             headOffice: u.headOffice?.toString() \n         })));\n+        \n+        // Debug: Convert headOfficeIds to strings for comparison\n+        const headOfficeIdsStrings = headOfficeIds.map(id => id.toString());\n+        console.log('DEBUG: HeadOffice IDs as strings:', headOfficeIdsStrings);\n+        console.log('DEBUG: Sample headOffice check - is Darbhanga in array?', headOfficeIdsStrings.includes(darbhangaId));\n+        \n+        // Debug: Test individual users specifically\n+        const chandanUser = await User.findOne({ email: 'chandan.kumar@gluckscare.com' }).select('name headOffice headOffices');\n+        const kshitizUser = await User.findOne({ email: 'kshitizmaurya6@gmail.com' }).select('name headOffice headOffices');\n+        \n+        console.log('DEBUG: Chandan headOffice:', chandanUser?.headOffice?.toString());\n+        console.log('DEBUG: Kshitiz headOffice:', kshitizUser?.headOffice?.toString());\n+        console.log('DEBUG: Does Chandan match query?', headOfficeIdsStrings.includes(chandanUser?.headOffice?.toString()));\n+        console.log('DEBUG: Does Kshitiz match query?', headOfficeIdsStrings.includes(kshitizUser?.headOffice?.toString()));\n \n         // Build query to find users in this state\n         // Include users who are:\n         // 1. Directly assigned to the state\n@@ -815,8 +829,27 @@\n                 // Multiple head offices assignment\n                 { headOffices: { $in: headOfficeIds } }\n             ]\n         };\n+        \n+        console.log('DEBUG: Final query:', JSON.stringify(query, null, 2));\n+        \n+        // Test each condition separately to find the issue\n+        const testQuery1 = { isActive: true, state: stateId };\n+        const testQuery2 = { isActive: true, headOffice: { $in: headOfficeIds } };\n+        const testQuery3 = { isActive: true, headOffices: { $in: headOfficeIds } };\n+        \n+        const [test1Results, test2Results, test3Results] = await Promise.all([\n+            User.find(testQuery1).select('name email'),\n+            User.find(testQuery2).select('name email'),\n+            User.find(testQuery3).select('name email')\n+        ]);\n+        \n+        console.log('DEBUG: Direct state query results:', test1Results.length);\n+        console.log('DEBUG: HeadOffice query results:', test2Results.length);\n+        console.log('DEBUG: HeadOffices query results:', test3Results.length);\n+        console.log('DEBUG: HeadOffice matches:', test2Results.map(u => u.name));\n+        console.log('DEBUG: HeadOffices matches:', test3Results.map(u => u.name));\n \n         // Add search filter if provided\n         if (search) {\n             query.$and = query.$and || [];\n"
                },
                {
                    "date": 1757005425049,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -987,21 +987,69 @@\n         const directStateUsers = await User.find({ isActive: true, state: stateId }).select('name email headOffice headOffices state');\n         const headOfficeUsers = await User.find({ isActive: true, headOffice: { $in: headOfficeIds } }).select('name email headOffice headOffices state');\n         const headOfficesUsers = await User.find({ isActive: true, headOffices: { $in: headOfficeIds } }).select('name email headOffice headOffices state');\n         \n+        // Test specific users\n+        const chandanUser = await User.findOne({ email: 'chandan.kumar@gluckscare.com' }).select('name headOffice headOffices');\n+        const kshitizUser = await User.findOne({ email: 'kshitizmaurya6@gmail.com' }).select('name headOffice headOffices');\n+        \n+        // Test Darbhanga specifically\n+        const darbhangaId = '68a42d720fd473dd1c3074d3';\n+        const darbhangaUsers = await User.find({ \n+            isActive: true, \n+            headOffice: darbhangaId \n+        }).select('name email headOffice');\n+        \n         res.json({\n             success: true,\n             debug: {\n                 stateId: stateId,\n                 stateName: stateHeadUser.state.name,\n                 headOfficesInState: headOfficesInState,\n-                directStateUsers: directStateUsers,\n-                headOfficeUsers: headOfficeUsers,\n-                headOfficesUsers: headOfficesUsers,\n+                headOfficeIds: headOfficeIds.map(id => id.toString()),\n+                directStateUsers: directStateUsers.map(u => ({\n+                    name: u.name,\n+                    email: u.email,\n+                    headOffice: u.headOffice?.toString(),\n+                    headOffices: u.headOffices?.map(ho => ho.toString())\n+                })),\n+                headOfficeUsers: headOfficeUsers.map(u => ({\n+                    name: u.name,\n+                    email: u.email,\n+                    headOffice: u.headOffice?.toString(),\n+                    headOffices: u.headOffices?.map(ho => ho.toString())\n+                })),\n+                headOfficesUsers: headOfficesUsers.map(u => ({\n+                    name: u.name,\n+                    email: u.email,\n+                    headOffice: u.headOffice?.toString(),\n+                    headOffices: u.headOffices?.map(ho => ho.toString())\n+                })),\n+                specificUsers: {\n+                    chandan: chandanUser ? {\n+                        name: chandanUser.name,\n+                        headOffice: chandanUser.headOffice?.toString(),\n+                        headOffices: chandanUser.headOffices?.map(ho => ho.toString())\n+                    } : null,\n+                    kshitiz: kshitizUser ? {\n+                        name: kshitizUser.name,\n+                        headOffice: kshitizUser.headOffice?.toString(),\n+                        headOffices: kshitizUser.headOffices?.map(ho => ho.toString())\n+                    } : null\n+                },\n+                darbhangaTest: {\n+                    isDarbhangaInArray: headOfficeIds.map(id => id.toString()).includes(darbhangaId),\n+                    darbhangaUsers: darbhangaUsers.map(u => ({\n+                        name: u.name,\n+                        email: u.email,\n+                        headOffice: u.headOffice?.toString()\n+                    }))\n+                },\n                 counts: {\n                     directState: directStateUsers.length,\n                     headOffice: headOfficeUsers.length,\n-                    headOffices: headOfficesUsers.length\n+                    headOffices: headOfficesUsers.length,\n+                    darbhanga: darbhangaUsers.length\n                 }\n             }\n         });\n     } catch (err) {\n"
                },
                {
                    "date": 1757005729476,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -816,40 +816,28 @@\n \n         // Build query to find users in this state\n         // Include users who are:\n         // 1. Directly assigned to the state\n-        // 2. Assigned to head offices in this state\n+        // 2. Assigned to head offices in this state (using headOffices array only)\n         \n         let query = {\n             isActive: true,\n             $or: [\n                 // Direct state assignment\n                 { state: stateId },\n-                // Head office assignment (single head office)\n-                { headOffice: { $in: headOfficeIds } },\n-                // Multiple head offices assignment\n+                // Multiple head offices assignment (headOffices array)\n                 { headOffices: { $in: headOfficeIds } }\n             ]\n         };\n         \n-        console.log('DEBUG: Final query:', JSON.stringify(query, null, 2));\n+        console.log('DEBUG: Final query (headOffices only):', JSON.stringify(query, null, 2));\n         \n-        // Test each condition separately to find the issue\n-        const testQuery1 = { isActive: true, state: stateId };\n-        const testQuery2 = { isActive: true, headOffice: { $in: headOfficeIds } };\n-        const testQuery3 = { isActive: true, headOffices: { $in: headOfficeIds } };\n+        // Test the headOffices query specifically\n+        const headOfficesOnlyQuery = { isActive: true, headOffices: { $in: headOfficeIds } };\n+        const headOfficesResults = await User.find(headOfficesOnlyQuery).select('name email headOffices');\n         \n-        const [test1Results, test2Results, test3Results] = await Promise.all([\n-            User.find(testQuery1).select('name email'),\n-            User.find(testQuery2).select('name email'),\n-            User.find(testQuery3).select('name email')\n-        ]);\n-        \n-        console.log('DEBUG: Direct state query results:', test1Results.length);\n-        console.log('DEBUG: HeadOffice query results:', test2Results.length);\n-        console.log('DEBUG: HeadOffices query results:', test3Results.length);\n-        console.log('DEBUG: HeadOffice matches:', test2Results.map(u => u.name));\n-        console.log('DEBUG: HeadOffices matches:', test3Results.map(u => u.name));\n+        console.log('DEBUG: HeadOffices only query results:', headOfficesResults.length);\n+        console.log('DEBUG: HeadOffices matches:', headOfficesResults.map(u => u.name));\n \n         // Add search filter if provided\n         if (search) {\n             query.$and = query.$and || [];\n@@ -998,8 +986,53 @@\n             isActive: true, \n             headOffice: darbhangaId \n         }).select('name email headOffice');\n         \n+        // Test Chandan specifically\n+        const chandanTest = await User.findOne({ \n+            email: 'chandan.kumar@gluckscare.com'\n+        }).select('name email headOffice isActive');\n+        \n+        // Test if Chandan matches the query conditions\n+        const chandanMatchesQuery = await User.findOne({ \n+            email: 'chandan.kumar@gluckscare.com',\n+            isActive: true,\n+            headOffice: { $in: headOfficeIds }\n+        }).select('name email headOffice isActive');\n+        \n+        // Test with exact headOffice match for Chandan\n+        const chandanExactMatch = await User.findOne({ \n+            email: 'chandan.kumar@gluckscare.com',\n+            isActive: true,\n+            headOffice: darbhangaId\n+        }).select('name email headOffice isActive');\n+        \n+        // Debug: Check data types\n+        const mongoose = require('mongoose');\n+        const chandanRaw = await User.findOne({ email: 'chandan.kumar@gluckscare.com' });\n+        const chandanHeadOfficeType = typeof chandanRaw?.headOffice;\n+        const chandanHeadOfficeValue = chandanRaw?.headOffice;\n+        const isObjectId = mongoose.Types.ObjectId.isValid(chandanHeadOfficeValue);\n+        const objectIdInstance = chandanHeadOfficeValue instanceof mongoose.Types.ObjectId;\n+        \n+        // Test direct ObjectId comparison\n+        const darbhangaObjectId = new mongoose.Types.ObjectId(darbhangaId);\n+        const chandanMatchesObjectId = await User.findOne({ \n+            email: 'chandan.kumar@gluckscare.com',\n+            headOffice: darbhangaObjectId\n+        });\n+        \n+        // Test if the issue is with the array vs single value\n+        const testSingleQuery = await User.findOne({ \n+            isActive: true,\n+            headOffice: darbhangaObjectId\n+        }).select('name email');\n+        \n+        const testArrayQuery = await User.findOne({ \n+            isActive: true,\n+            headOffice: { $in: [darbhangaObjectId] }\n+        }).select('name email');\n+        \n         res.json({\n             success: true,\n             debug: {\n                 stateId: stateId,\n@@ -1041,9 +1074,27 @@\n                     darbhangaUsers: darbhangaUsers.map(u => ({\n                         name: u.name,\n                         email: u.email,\n                         headOffice: u.headOffice?.toString()\n-                    }))\n+                    })),\n+                    chandanTest: chandanTest ? {\n+                        name: chandanTest.name,\n+                        email: chandanTest.email,\n+                        headOffice: chandanTest.headOffice?.toString(),\n+                        isActive: chandanTest.isActive\n+                    } : null,\n+                    chandanMatchesQuery: chandanMatchesQuery ? {\n+                        name: chandanMatchesQuery.name,\n+                        email: chandanMatchesQuery.email,\n+                        headOffice: chandanMatchesQuery.headOffice?.toString(),\n+                        isActive: chandanMatchesQuery.isActive\n+                    } : null,\n+                    chandanExactMatch: chandanExactMatch ? {\n+                        name: chandanExactMatch.name,\n+                        email: chandanExactMatch.email,\n+                        headOffice: chandanExactMatch.headOffice?.toString(),\n+                        isActive: chandanExactMatch.isActive\n+                    } : null\n                 },\n                 counts: {\n                     directState: directStateUsers.length,\n                     headOffice: headOfficeUsers.length,\n"
                },
                {
                    "date": 1757005756328,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -971,68 +971,15 @@\n \n         const headOfficeIds = headOfficesInState.map(ho => ho._id);\n         \n         // Test individual conditions\n-        const directStateUsers = await User.find({ isActive: true, state: stateId }).select('name email headOffice headOffices state');\n-        const headOfficeUsers = await User.find({ isActive: true, headOffice: { $in: headOfficeIds } }).select('name email headOffice headOffices state');\n-        const headOfficesUsers = await User.find({ isActive: true, headOffices: { $in: headOfficeIds } }).select('name email headOffice headOffices state');\n+        const directStateUsers = await User.find({ isActive: true, state: stateId }).select('name email headOffices state');\n+        const headOfficesUsers = await User.find({ isActive: true, headOffices: { $in: headOfficeIds } }).select('name email headOffices state');\n         \n         // Test specific users\n-        const chandanUser = await User.findOne({ email: 'chandan.kumar@gluckscare.com' }).select('name headOffice headOffices');\n-        const kshitizUser = await User.findOne({ email: 'kshitizmaurya6@gmail.com' }).select('name headOffice headOffices');\n+        const chandanUser = await User.findOne({ email: 'chandan.kumar@gluckscare.com' }).select('name headOffices');\n+        const kshitizUser = await User.findOne({ email: 'kshitizmaurya6@gmail.com' }).select('name headOffices');\n         \n-        // Test Darbhanga specifically\n-        const darbhangaId = '68a42d720fd473dd1c3074d3';\n-        const darbhangaUsers = await User.find({ \n-            isActive: true, \n-            headOffice: darbhangaId \n-        }).select('name email headOffice');\n-        \n-        // Test Chandan specifically\n-        const chandanTest = await User.findOne({ \n-            email: 'chandan.kumar@gluckscare.com'\n-        }).select('name email headOffice isActive');\n-        \n-        // Test if Chandan matches the query conditions\n-        const chandanMatchesQuery = await User.findOne({ \n-            email: 'chandan.kumar@gluckscare.com',\n-            isActive: true,\n-            headOffice: { $in: headOfficeIds }\n-        }).select('name email headOffice isActive');\n-        \n-        // Test with exact headOffice match for Chandan\n-        const chandanExactMatch = await User.findOne({ \n-            email: 'chandan.kumar@gluckscare.com',\n-            isActive: true,\n-            headOffice: darbhangaId\n-        }).select('name email headOffice isActive');\n-        \n-        // Debug: Check data types\n-        const mongoose = require('mongoose');\n-        const chandanRaw = await User.findOne({ email: 'chandan.kumar@gluckscare.com' });\n-        const chandanHeadOfficeType = typeof chandanRaw?.headOffice;\n-        const chandanHeadOfficeValue = chandanRaw?.headOffice;\n-        const isObjectId = mongoose.Types.ObjectId.isValid(chandanHeadOfficeValue);\n-        const objectIdInstance = chandanHeadOfficeValue instanceof mongoose.Types.ObjectId;\n-        \n-        // Test direct ObjectId comparison\n-        const darbhangaObjectId = new mongoose.Types.ObjectId(darbhangaId);\n-        const chandanMatchesObjectId = await User.findOne({ \n-            email: 'chandan.kumar@gluckscare.com',\n-            headOffice: darbhangaObjectId\n-        });\n-        \n-        // Test if the issue is with the array vs single value\n-        const testSingleQuery = await User.findOne({ \n-            isActive: true,\n-            headOffice: darbhangaObjectId\n-        }).select('name email');\n-        \n-        const testArrayQuery = await User.findOne({ \n-            isActive: true,\n-            headOffice: { $in: [darbhangaObjectId] }\n-        }).select('name email');\n-        \n         res.json({\n             success: true,\n             debug: {\n                 stateId: stateId,\n@@ -1041,66 +988,28 @@\n                 headOfficeIds: headOfficeIds.map(id => id.toString()),\n                 directStateUsers: directStateUsers.map(u => ({\n                     name: u.name,\n                     email: u.email,\n-                    headOffice: u.headOffice?.toString(),\n                     headOffices: u.headOffices?.map(ho => ho.toString())\n                 })),\n-                headOfficeUsers: headOfficeUsers.map(u => ({\n-                    name: u.name,\n-                    email: u.email,\n-                    headOffice: u.headOffice?.toString(),\n-                    headOffices: u.headOffices?.map(ho => ho.toString())\n-                })),\n                 headOfficesUsers: headOfficesUsers.map(u => ({\n                     name: u.name,\n                     email: u.email,\n-                    headOffice: u.headOffice?.toString(),\n                     headOffices: u.headOffices?.map(ho => ho.toString())\n                 })),\n                 specificUsers: {\n                     chandan: chandanUser ? {\n                         name: chandanUser.name,\n-                        headOffice: chandanUser.headOffice?.toString(),\n                         headOffices: chandanUser.headOffices?.map(ho => ho.toString())\n                     } : null,\n                     kshitiz: kshitizUser ? {\n                         name: kshitizUser.name,\n-                        headOffice: kshitizUser.headOffice?.toString(),\n                         headOffices: kshitizUser.headOffices?.map(ho => ho.toString())\n                     } : null\n                 },\n-                darbhangaTest: {\n-                    isDarbhangaInArray: headOfficeIds.map(id => id.toString()).includes(darbhangaId),\n-                    darbhangaUsers: darbhangaUsers.map(u => ({\n-                        name: u.name,\n-                        email: u.email,\n-                        headOffice: u.headOffice?.toString()\n-                    })),\n-                    chandanTest: chandanTest ? {\n-                        name: chandanTest.name,\n-                        email: chandanTest.email,\n-                        headOffice: chandanTest.headOffice?.toString(),\n-                        isActive: chandanTest.isActive\n-                    } : null,\n-                    chandanMatchesQuery: chandanMatchesQuery ? {\n-                        name: chandanMatchesQuery.name,\n-                        email: chandanMatchesQuery.email,\n-                        headOffice: chandanMatchesQuery.headOffice?.toString(),\n-                        isActive: chandanMatchesQuery.isActive\n-                    } : null,\n-                    chandanExactMatch: chandanExactMatch ? {\n-                        name: chandanExactMatch.name,\n-                        email: chandanExactMatch.email,\n-                        headOffice: chandanExactMatch.headOffice?.toString(),\n-                        isActive: chandanExactMatch.isActive\n-                    } : null\n-                },\n                 counts: {\n                     directState: directStateUsers.length,\n-                    headOffice: headOfficeUsers.length,\n-                    headOffices: headOfficesUsers.length,\n-                    darbhanga: darbhangaUsers.length\n+                    headOffices: headOfficesUsers.length\n                 }\n             }\n         });\n     } catch (err) {\n"
                },
                {
                    "date": 1757005774730,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -766,54 +766,19 @@\n         console.log('DEBUG: State ID:', stateId);\n         console.log('DEBUG: Head offices in state:', headOfficeIds.length);\n         console.log('DEBUG: Head office IDs:', headOfficeIds.map(id => id.toString()));\n         \n-        // Debug: Test if Darbhanga is in the list\n+        // Debug: Test headOffices array functionality\n         const darbhangaId = '68a42d720fd473dd1c3074d3';\n         const isDarbhangaIncluded = headOfficeIds.some(id => id.toString() === darbhangaId);\n         console.log('DEBUG: Is Darbhanga included?', isDarbhangaIncluded);\n         \n-        // Debug: Count users with Darbhanga head office\n-        const darbhangaCount = await User.countDocuments({ \n+        // Debug: Count users with Darbhanga in headOffices array\n+        const darbhangaUsersCount = await User.countDocuments({ \n             isActive: true, \n-            headOffice: darbhangaId \n+            headOffices: darbhangaId \n         });\n-        console.log('DEBUG: Users with Darbhanga headOffice:', darbhangaCount);\n-        \n-        // Debug: Get all users with Darbhanga head office to see why they're not matching\n-        const darbhangaUsers = await User.find({ \n-            isActive: true, \n-            headOffice: darbhangaId \n-        }).select('name email headOffice headOffices');\n-        console.log('DEBUG: Darbhanga users found:', darbhangaUsers.map(u => ({ \n-            name: u.name, \n-            email: u.email, \n-            headOffice: u.headOffice?.toString(), \n-            headOffices: u.headOffices \n-        })));\n-        \n-        // Debug: Test the exact query condition for headOffice field\n-        const headOfficeQuery = { isActive: true, headOffice: { $in: headOfficeIds } };\n-        const headOfficeMatches = await User.find(headOfficeQuery).select('name email headOffice');\n-        console.log('DEBUG: Users matching headOffice $in query:', headOfficeMatches.map(u => ({ \n-            name: u.name, \n-            email: u.email, \n-            headOffice: u.headOffice?.toString() \n-        })));\n-        \n-        // Debug: Convert headOfficeIds to strings for comparison\n-        const headOfficeIdsStrings = headOfficeIds.map(id => id.toString());\n-        console.log('DEBUG: HeadOffice IDs as strings:', headOfficeIdsStrings);\n-        console.log('DEBUG: Sample headOffice check - is Darbhanga in array?', headOfficeIdsStrings.includes(darbhangaId));\n-        \n-        // Debug: Test individual users specifically\n-        const chandanUser = await User.findOne({ email: 'chandan.kumar@gluckscare.com' }).select('name headOffice headOffices');\n-        const kshitizUser = await User.findOne({ email: 'kshitizmaurya6@gmail.com' }).select('name headOffice headOffices');\n-        \n-        console.log('DEBUG: Chandan headOffice:', chandanUser?.headOffice?.toString());\n-        console.log('DEBUG: Kshitiz headOffice:', kshitizUser?.headOffice?.toString());\n-        console.log('DEBUG: Does Chandan match query?', headOfficeIdsStrings.includes(chandanUser?.headOffice?.toString()));\n-        console.log('DEBUG: Does Kshitiz match query?', headOfficeIdsStrings.includes(kshitizUser?.headOffice?.toString()));\n+        console.log('DEBUG: Users with Darbhanga in headOffices array:', darbhangaUsersCount);\n \n         // Build query to find users in this state\n         // Include users who are:\n         // 1. Directly assigned to the state\n"
                },
                {
                    "date": 1757006167605,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -801,8 +801,42 @@\n         const headOfficesResults = await User.find(headOfficesOnlyQuery).select('name email headOffices');\n         \n         console.log('DEBUG: HeadOffices only query results:', headOfficesResults.length);\n         console.log('DEBUG: HeadOffices matches:', headOfficesResults.map(u => u.name));\n+        \n+        // Debug: Test individual user queries\n+        const chandanHasDarbhanga = await User.findOne({ \n+            email: 'chandan.kumar@gluckscare.com',\n+            headOffices: darbhangaId\n+        });\n+        console.log('DEBUG: Does Chandan have Darbhanga in headOffices?', !!chandanHasDarbhanga);\n+        \n+        const kshitizHasDarbhanga = await User.findOne({ \n+            email: 'kshitizmaurya6@gmail.com',\n+            headOffices: darbhangaId\n+        });\n+        console.log('DEBUG: Does Kshitiz have Darbhanga in headOffices?', !!kshitizHasDarbhanga);\n+        \n+        // Debug: Test with array of IDs\n+        const chandanHasAnyHeadOffice = await User.findOne({ \n+            email: 'chandan.kumar@gluckscare.com',\n+            headOffices: { $in: [darbhangaId] }\n+        });\n+        console.log('DEBUG: Does Chandan match $in query?', !!chandanHasAnyHeadOffice);\n+        \n+        // Debug: Get raw data for both users to compare\n+        const chandanRaw = await User.findOne({ email: 'chandan.kumar@gluckscare.com' }).select('name headOffices');\n+        const kshitizRaw = await User.findOne({ email: 'kshitizmaurya6@gmail.com' }).select('name headOffices');\n+        \n+        console.log('DEBUG: Chandan raw headOffices:', JSON.stringify(chandanRaw?.headOffices));\n+        console.log('DEBUG: Kshitiz raw headOffices:', JSON.stringify(kshitizRaw?.headOffices));\n+        \n+        // Debug: Test with exact array values\n+        const chandanExactArray = await User.findOne({ \n+            email: 'chandan.kumar@gluckscare.com',\n+            headOffices: { $all: [darbhangaId] }\n+        });\n+        console.log('DEBUG: Does Chandan match $all query?', !!chandanExactArray);\n \n         // Add search filter if provided\n         if (search) {\n             query.$and = query.$and || [];\n@@ -832,14 +866,13 @@\n         const [users, totalCount] = await Promise.all([\n             User.find(query)\n                 .populate('department', 'name')\n                 .populate('designation', 'name')\n-                .populate('headOffice', 'name state')\n                 .populate('headOffices', 'name state')\n                 .populate('state', 'name')\n                 .populate('branch', 'name')\n                 .populate('employmentType', 'name')\n-                .select('employeeCode name email role department headOffice headOffices state branch employmentType mobileNumber dateOfJoining salaryAmount isActive createdAt')\n+                .select('employeeCode name email role department headOffices state branch employmentType mobileNumber dateOfJoining salaryAmount isActive createdAt')\n                 .sort({ name: 1 })\n                 .skip(skip)\n                 .limit(parseInt(limit)),\n             User.countDocuments(query)\n@@ -852,9 +885,9 @@\n             name: user.name,\n             email: user.email,\n             role: user.role,\n             department: user.department?.name || 'Not Assigned',\n-            headOffice: user.headOffice?.name || 'Not Assigned',\n+            headOffice: user.headOffices && user.headOffices.length > 0 ? user.headOffices[0].name : 'Not Assigned',\n             headOffices: user.headOffices?.map(ho => ho.name).join(', ') || 'Not Assigned',\n             state: user.state?.name || stateHeadUser.state.name,\n             branch: user.branch?.name || 'Not Assigned',\n             employmentType: user.employmentType?.name || 'Not Assigned',\n"
                },
                {
                    "date": 1757007848587,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -762,24 +762,8 @@\n         }).select('_id');\n \n         const headOfficeIds = headOfficesInState.map(ho => ho._id);\n         \n-        console.log('DEBUG: State ID:', stateId);\n-        console.log('DEBUG: Head offices in state:', headOfficeIds.length);\n-        console.log('DEBUG: Head office IDs:', headOfficeIds.map(id => id.toString()));\n-        \n-        // Debug: Test headOffices array functionality\n-        const darbhangaId = '68a42d720fd473dd1c3074d3';\n-        const isDarbhangaIncluded = headOfficeIds.some(id => id.toString() === darbhangaId);\n-        console.log('DEBUG: Is Darbhanga included?', isDarbhangaIncluded);\n-        \n-        // Debug: Count users with Darbhanga in headOffices array\n-        const darbhangaUsersCount = await User.countDocuments({ \n-            isActive: true, \n-            headOffices: darbhangaId \n-        });\n-        console.log('DEBUG: Users with Darbhanga in headOffices array:', darbhangaUsersCount);\n-\n         // Build query to find users in this state\n         // Include users who are:\n         // 1. Directly assigned to the state\n         // 2. Assigned to head offices in this state (using headOffices array only)\n@@ -792,51 +776,8 @@\n                 // Multiple head offices assignment (headOffices array)\n                 { headOffices: { $in: headOfficeIds } }\n             ]\n         };\n-        \n-        console.log('DEBUG: Final query (headOffices only):', JSON.stringify(query, null, 2));\n-        \n-        // Test the headOffices query specifically\n-        const headOfficesOnlyQuery = { isActive: true, headOffices: { $in: headOfficeIds } };\n-        const headOfficesResults = await User.find(headOfficesOnlyQuery).select('name email headOffices');\n-        \n-        console.log('DEBUG: HeadOffices only query results:', headOfficesResults.length);\n-        console.log('DEBUG: HeadOffices matches:', headOfficesResults.map(u => u.name));\n-        \n-        // Debug: Test individual user queries\n-        const chandanHasDarbhanga = await User.findOne({ \n-            email: 'chandan.kumar@gluckscare.com',\n-            headOffices: darbhangaId\n-        });\n-        console.log('DEBUG: Does Chandan have Darbhanga in headOffices?', !!chandanHasDarbhanga);\n-        \n-        const kshitizHasDarbhanga = await User.findOne({ \n-            email: 'kshitizmaurya6@gmail.com',\n-            headOffices: darbhangaId\n-        });\n-        console.log('DEBUG: Does Kshitiz have Darbhanga in headOffices?', !!kshitizHasDarbhanga);\n-        \n-        // Debug: Test with array of IDs\n-        const chandanHasAnyHeadOffice = await User.findOne({ \n-            email: 'chandan.kumar@gluckscare.com',\n-            headOffices: { $in: [darbhangaId] }\n-        });\n-        console.log('DEBUG: Does Chandan match $in query?', !!chandanHasAnyHeadOffice);\n-        \n-        // Debug: Get raw data for both users to compare\n-        const chandanRaw = await User.findOne({ email: 'chandan.kumar@gluckscare.com' }).select('name headOffices');\n-        const kshitizRaw = await User.findOne({ email: 'kshitizmaurya6@gmail.com' }).select('name headOffices');\n-        \n-        console.log('DEBUG: Chandan raw headOffices:', JSON.stringify(chandanRaw?.headOffices));\n-        console.log('DEBUG: Kshitiz raw headOffices:', JSON.stringify(kshitizRaw?.headOffices));\n-        \n-        // Debug: Test with exact array values\n-        const chandanExactArray = await User.findOne({ \n-            email: 'chandan.kumar@gluckscare.com',\n-            headOffices: { $all: [darbhangaId] }\n-        });\n-        console.log('DEBUG: Does Chandan match $all query?', !!chandanExactArray);\n \n         // Add search filter if provided\n         if (search) {\n             query.$and = query.$and || [];\n@@ -1100,12 +1041,8 @@\n         if (role) {\n             query.role = role;\n         }\n \n-        // Debug: Log the final query\n-        console.log('Shift assignment query:', JSON.stringify(query, null, 2));\n-        console.log('Query parameters:', { search, department, role, page, limit, includeInactive, excludeAdmins });\n-\n         // Calculate pagination\n         const skip = (parseInt(page) - 1) * parseInt(limit);\n \n         // Execute queries in parallel for better performance\n"
                },
                {
                    "date": 1757009536237,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -826,16 +826,14 @@\n             name: user.name,\n             email: user.email,\n             role: user.role,\n             department: user.department?.name || 'Not Assigned',\n-            headOffice: user.headOffices && user.headOffices.length > 0 ? user.headOffices[0].name : 'Not Assigned',\n             headOffices: user.headOffices?.map(ho => ho.name).join(', ') || 'Not Assigned',\n             state: user.state?.name || stateHeadUser.state.name,\n             branch: user.branch?.name || 'Not Assigned',\n             employmentType: user.employmentType?.name || 'Not Assigned',\n             mobileNumber: user.mobileNumber,\n             dateOfJoining: user.dateOfJoining,\n-            salaryAmount: user.salaryAmount,\n             isActive: user.isActive,\n             createdAt: user.createdAt\n         }));\n \n"
                },
                {
                    "date": 1757009643460,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -811,9 +811,9 @@\n                 .populate('headOffices', 'name state')\n                 .populate('state', 'name')\n                 .populate('branch', 'name')\n                 .populate('employmentType', 'name')\n-                .select('employeeCode name email role department headOffices state branch employmentType mobileNumber dateOfJoining salaryAmount isActive createdAt')\n+                .select('employeeCode name email role department headOffices state branch employmentType mobileNumber dateOfJoining isActive createdAt')\n                 .sort({ name: 1 })\n                 .skip(skip)\n                 .limit(parseInt(limit)),\n             User.countDocuments(query)\n"
                },
                {
                    "date": 1757009687893,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -826,16 +826,12 @@\n             name: user.name,\n             email: user.email,\n             role: user.role,\n             department: user.department?.name || 'Not Assigned',\n-            headOffices: user.headOffices?.map(ho => ho.name).join(', ') || 'Not Assigned',\n-            state: user.state?.name || stateHeadUser.state.name,\n-            branch: user.branch?.name || 'Not Assigned',\n-            employmentType: user.employmentType?.name || 'Not Assigned',\n+            state: user.state?.name || 'Not Assigned',\n             mobileNumber: user.mobileNumber,\n             dateOfJoining: user.dateOfJoining,\n-            isActive: user.isActive,\n-            createdAt: user.createdAt\n+            isActive: user.isActive\n         }));\n \n         // Calculate pagination info\n         const totalPages = Math.ceil(totalCount / limit);\n"
                },
                {
                    "date": 1757009728499,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -826,12 +826,16 @@\n             name: user.name,\n             email: user.email,\n             role: user.role,\n             department: user.department?.name || 'Not Assigned',\n-            state: user.state?.name || 'Not Assigned',\n+            headOffices: user.headOffices?.map(ho => ho.name).join(', ') || 'Not Assigned',\n+            state: user.state?.name || stateHeadUser.state.name,\n+            branch: user.branch?.name || 'Not Assigned',\n+            employmentType: user.employmentType?.name || 'Not Assigned',\n             mobileNumber: user.mobileNumber,\n             dateOfJoining: user.dateOfJoining,\n-            isActive: user.isActive\n+            isActive: user.isActive,\n+            createdAt: user.createdAt\n         }));\n \n         // Calculate pagination info\n         const totalPages = Math.ceil(totalCount / limit);\n"
                },
                {
                    "date": 1757009834586,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -956,8 +956,13 @@\n             message: err.message || 'Server error'\n         });\n     }\n };\n+\n+/**\n+ * Get my head offices\n+ * GET /api/users/my-headoffices\n+ */\n exports.getMyHeadOffices = async(req, res) => {\n     try {\n         const user = await User.findById(req.user.id)\n             .populate('headOffice', 'name code')\n@@ -983,9 +988,8 @@\n             success: true,\n             data: headOffices\n         });\n     } catch (err) {\n-        console.error('Get my head offices error:', err);\n         res.status(500).json({\n             success: false,\n             message: err.message || 'Server error'\n         });\n"
                },
                {
                    "date": 1757010309086,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -871,95 +871,8 @@\n     }\n };\n \n /**\n- * Debug endpoint to test user queries by state\n- * GET /api/users/debug-by-state\n- */\n-exports.debugUsersByState = async(req, res) => {\n-    try {\n-        const currentUser = req.user;\n-\n-        // Check if the current user is a State Head\n-        if (!currentUser || currentUser.role !== 'State Head') {\n-            return res.status(403).json({\n-                success: false,\n-                message: 'Access denied. Only State Heads can access this endpoint.'\n-            });\n-        }\n-\n-        // Get the current user's state\n-        const stateHeadUser = await User.findById(currentUser.id).populate('state');\n-        \n-        if (!stateHeadUser || !stateHeadUser.state) {\n-            return res.status(400).json({\n-                success: false,\n-                message: 'State Head must be assigned to a state to view users.'\n-            });\n-        }\n-\n-        const stateId = stateHeadUser.state._id;\n-\n-        // Get head offices in the state\n-        const HeadOffice = require('../headoffice/Model');\n-        const headOfficesInState = await HeadOffice.find({ \n-            state: stateId, \n-            isActive: true \n-        }).select('_id name');\n-\n-        const headOfficeIds = headOfficesInState.map(ho => ho._id);\n-        \n-        // Test individual conditions\n-        const directStateUsers = await User.find({ isActive: true, state: stateId }).select('name email headOffices state');\n-        const headOfficesUsers = await User.find({ isActive: true, headOffices: { $in: headOfficeIds } }).select('name email headOffices state');\n-        \n-        // Test specific users\n-        const chandanUser = await User.findOne({ email: 'chandan.kumar@gluckscare.com' }).select('name headOffices');\n-        const kshitizUser = await User.findOne({ email: 'kshitizmaurya6@gmail.com' }).select('name headOffices');\n-        \n-        res.json({\n-            success: true,\n-            debug: {\n-                stateId: stateId,\n-                stateName: stateHeadUser.state.name,\n-                headOfficesInState: headOfficesInState,\n-                headOfficeIds: headOfficeIds.map(id => id.toString()),\n-                directStateUsers: directStateUsers.map(u => ({\n-                    name: u.name,\n-                    email: u.email,\n-                    headOffices: u.headOffices?.map(ho => ho.toString())\n-                })),\n-                headOfficesUsers: headOfficesUsers.map(u => ({\n-                    name: u.name,\n-                    email: u.email,\n-                    headOffices: u.headOffices?.map(ho => ho.toString())\n-                })),\n-                specificUsers: {\n-                    chandan: chandanUser ? {\n-                        name: chandanUser.name,\n-                        headOffices: chandanUser.headOffices?.map(ho => ho.toString())\n-                    } : null,\n-                    kshitiz: kshitizUser ? {\n-                        name: kshitizUser.name,\n-                        headOffices: kshitizUser.headOffices?.map(ho => ho.toString())\n-                    } : null\n-                },\n-                counts: {\n-                    directState: directStateUsers.length,\n-                    headOffices: headOfficesUsers.length\n-                }\n-            }\n-        });\n-    } catch (err) {\n-        console.error('Debug users by state error:', err);\n-        res.status(500).json({\n-            success: false,\n-            message: err.message || 'Server error'\n-        });\n-    }\n-};\n-\n-/**\n  * Get my head offices\n  * GET /api/users/my-headoffices\n  */\n exports.getMyHeadOffices = async(req, res) => {\n"
                }
            ],
            "date": 1757004156693,
            "name": "Commit-0",
            "content": "// controllers/userController.js\nconst User = require('./User');\nconst bcrypt = require('bcryptjs');\n\n/**\n * Get all users with enhanced pagination and search\n * GET /api/users\n */\nexports.getAllUsers = async(req, res) => {\n    try {\n        const { \n            role, \n            branch, \n            department, \n            search, \n            page = 1, \n            limit = 20,\n            sortBy = 'name',\n            sortOrder = 'asc',\n            isActive\n        } = req.query;\n        \n        let query = {};\n\n        // Basic filters\n        if (role) query.role = role;\n        if (branch) query.branch = branch;\n        if (department) query.department = department;\n        if (isActive !== undefined) query.isActive = isActive === 'true';\n\n        // Search functionality\n        if (search) {\n            const searchRegex = new RegExp(search, 'i');\n            query.$or = [\n                { name: searchRegex },\n                { email: searchRegex },\n                { employeeCode: searchRegex },\n                { mobileNumber: searchRegex }\n            ];\n        }\n\n        // Pagination\n        const skip = (parseInt(page) - 1) * parseInt(limit);\n        const sortOptions = {};\n        sortOptions[sortBy] = sortOrder === 'desc' ? -1 : 1;\n\n        // Execute queries in parallel for better performance\n        const [users, totalCount] = await Promise.all([\n            User.find(query)\n                .populate('branch', 'name code')\n                .populate('department', 'name code')\n                .populate('designation', 'name description')\n                .populate('employmentType', 'name code')\n                .populate('headOffice', 'name code')\n                .populate('headOffices', 'name code')\n                .populate('manager', 'name email role')\n                .populate('managers', 'name email role')\n                .populate('areaManagers', 'name email role')\n                .populate('state', 'name code')\n                .populate('createdBy', 'name')\n                .populate('updatedBy', 'name')\n                .select('-password -legalDocuments')\n                .sort(sortOptions)\n                .skip(skip)\n                .limit(parseInt(limit)),\n            User.countDocuments(query)\n        ]);\n\n        // Calculate pagination info\n        const totalPages = Math.ceil(totalCount / parseInt(limit));\n        const hasNext = parseInt(page) < totalPages;\n        const hasPrev = parseInt(page) > 1;\n\n        res.json({\n            success: true,\n            data: users,\n            pagination: {\n                currentPage: parseInt(page),\n                totalPages,\n                totalCount,\n                limit: parseInt(limit),\n                hasNext,\n                hasPrev\n            },\n            filters: {\n                role,\n                branch,\n                department,\n                search,\n                isActive\n            }\n        });\n    } catch (err) {\n        console.error('Get all users error:', err);\n        res.status(500).json({\n            success: false,\n            message: err.message || 'Server error'\n        });\n    }\n};\n\n/**\n * Get users by role\n * GET /api/users/role/:role\n */\nexports.getUsersByRole = async(req, res) => {\n    try {\n        const { role } = req.params;\n        const users = await User.find({ role })\n            .populate('branch', 'name code')\n            .populate('department', 'name code')\n            .populate('designation', 'name description')\n            .populate('employmentType', 'name code')\n            .populate('headOffice', 'name code')\n            .populate('headOffices', 'name code')\n            .populate('manager', 'name email role')\n            .populate('managers', 'name email role')\n            .populate('areaManagers', 'name email role')\n            .populate('state', 'name code')\n            .select('-password -legalDocuments'); // Exclude sensitive data\n\n        res.json({\n            success: true,\n            count: users.length,\n            data: users\n        });\n    } catch (err) {\n        console.error('Get users by role error:', err);\n        res.status(500).json({\n            success: false,\n            message: err.message || 'Server error'\n        });\n    }\n};\n\n/**\n * Get user by ID\n * GET /api/users/:id\n */\nexports.getUserById = async(req, res) => {\n    try {\n        const user = await User.findById(req.params.id)\n            .populate('branch', 'name code')\n            .populate('department', 'name code')\n            .populate('designation', 'name description')\n            .populate('employmentType', 'name code')\n            .populate('headOffice', 'name code')\n            .populate('headOffices', 'name code')\n            .populate('manager', 'name email role')\n            .populate('managers', 'name email role')\n            .populate('areaManagers', 'name email role')\n            .populate('state', 'name code')\n            .select('-password'); // Exclude password\n\n        if (!user) {\n            return res.status(404).json({\n                success: false,\n                message: 'User not found'\n            });\n        }\n\n        res.json({\n            success: true,\n            data: user\n        });\n    } catch (err) {\n        console.error('Get user by ID error:', err);\n        res.status(500).json({\n            success: false,\n            message: err.message || 'Server error'\n        });\n    }\n};\n\n/**\n * Create new user\n * POST /api/users\n */\nexports.createUser = async(req, res) => {\n    try {\n        const cloudinary = require('../config/cloudinary');\n\n        // Check if user with same email or employeeCode exists\n        const existingUser = await User.findOne({\n            $or: [\n                { email: req.body.email },\n                { employeeCode: req.body.employeeCode }\n            ]\n        });\n\n        if (existingUser) {\n            return res.status(400).json({\n                success: false,\n                message: 'User with this email or employee code already exists'\n            });\n        }\n\n        // Handle file uploads to Cloudinary\n        const legalDocuments = {};\n\n        if (req.files) {\n            // Upload each document to Cloudinary\n            for (const [fieldName, file] of Object.entries(req.files)) {\n                if (['aadharCard', 'panCard', 'drivingLicense', 'passportPhoto'].includes(fieldName)) {\n                    try {\n                        const result = await cloudinary.uploader.upload(file[0].path, {\n                            folder: `users/${req.body.employeeCode}/documents`,\n                            resource_type: 'auto'\n                        });\n                        legalDocuments[fieldName] = result.secure_url;\n                    } catch (uploadError) {\n                        console.error(`Error uploading ${fieldName}:`, uploadError);\n                    }\n                }\n            }\n        }\n\n        // Parse nested objects if they come as strings\n        const userData = {...req.body };\n\n        if (typeof userData.bankDetails === 'string') {\n            userData.bankDetails = JSON.parse(userData.bankDetails);\n        }\n        if (typeof userData.emergencyContact === 'string') {\n            userData.emergencyContact = JSON.parse(userData.emergencyContact);\n        }\n        if (typeof userData.reference === 'string') {\n            userData.reference = JSON.parse(userData.reference);\n        }\n\n        // Handle ObjectId fields - extract _id if object is sent\n        const objectIdFields = ['branch', 'department', 'employmentType', 'headOffice', 'state'];\n        objectIdFields.forEach(field => {\n            if (userData[field] && typeof userData[field] === 'object' && userData[field]._id) {\n                userData[field] = userData[field]._id;\n            }\n        });\n\n        // Handle array ObjectId fields\n        const arrayObjectIdFields = ['headOffices', 'managers', 'areaManagers'];\n        arrayObjectIdFields.forEach(field => {\n            if (userData[field] && Array.isArray(userData[field])) {\n                userData[field] = userData[field]\n                    .map(item => {\n                        if (typeof item === 'object' && item._id) {\n                            return item._id;\n                        }\n                        return item;\n                    })\n                    .filter(id => id && id !== '');\n            }\n        });\n\n        // Auto-set headOffice from headOffices array if provided\n        if (userData.headOffices && Array.isArray(userData.headOffices) && userData.headOffices.length > 0) {\n            userData.headOffice = userData.headOffices[0];\n        }\n\n        // Add legal documents URLs\n        if (Object.keys(legalDocuments).length > 0) {\n            userData.legalDocuments = legalDocuments;\n        }\n\n        // Add audit info\n        if (req.user) {\n            userData.createdBy = req.user.id;\n        }\n\n        const newUser = new User(userData);\n        const savedUser = await newUser.save();\n\n        // Remove password from response\n        const userResponse = savedUser.toObject();\n        delete userResponse.password;\n\n        res.status(201).json({\n            success: true,\n            message: 'User created successfully',\n            data: userResponse\n        });\n    } catch (err) {\n        console.error('Create user error:', err);\n        res.status(500).json({\n            success: false,\n            message: err.message || 'Server error'\n        });\n    }\n};\n\n/**\n * Update user by ID\n * PUT /api/users/:id\n */\nexports.updateUser = async(req, res) => {\n    try {\n        const cloudinary = require('../config/cloudinary');\n\n        // Check permissions - only admins or the user themselves can update\n        if (!req.user ||\n            (req.user.id !== req.params.id &&\n                !['Admin', 'Super Admin'].includes(req.user.role))) {\n            return res.status(403).json({\n                success: false,\n                message: 'Access denied'\n            });\n        }\n\n        // Handle file uploads to Cloudinary\n        const updateData = {...req.body };\n\n        // Convert empty strings to undefined for ObjectId fields\n        const objectIdFields = [\n            'branch',\n            'department',\n            'employmentType',\n            'headOffice',\n            'state',\n            'manager',\n            'createdBy',\n            'updatedBy'\n        ];\n\n        objectIdFields.forEach(field => {\n            if (updateData[field] === '') {\n                updateData[field] = undefined;\n            } else if (updateData[field] && typeof updateData[field] === 'object' && updateData[field]._id) {\n                // If frontend sends object with _id, extract just the _id\n                updateData[field] = updateData[field]._id;\n            }\n        });\n\n        // Handle array ObjectId fields\n        const arrayObjectIdFields = ['headOffices', 'managers', 'areaManagers'];\n        arrayObjectIdFields.forEach(field => {\n            if (updateData[field]) {\n                if (Array.isArray(updateData[field])) {\n                    // Extract _id from objects if needed and filter out empty values\n                    updateData[field] = updateData[field]\n                        .map(item => {\n                            if (typeof item === 'object' && item._id) {\n                                return item._id;\n                            }\n                            return item;\n                        })\n                        .filter(id => id && id !== '');\n                } else if (updateData[field] === '') {\n                    updateData[field] = undefined;\n                }\n            }\n        });\n\n        // Auto-set headOffice from headOffices array if provided\n        if (updateData.headOffices && Array.isArray(updateData.headOffices) && updateData.headOffices.length > 0) {\n            updateData.headOffice = updateData.headOffices[0];\n        }\n\n        if (req.files) {\n            const currentUser = await User.findById(req.params.id);\n            if (!updateData.legalDocuments) {\n                updateData.legalDocuments = currentUser.legalDocuments || {};\n            }\n\n            // Upload each new document to Cloudinary\n            for (const [fieldName, file] of Object.entries(req.files)) {\n                if (['aadharCard', 'panCard', 'drivingLicense', 'passportPhoto'].includes(fieldName)) {\n                    try {\n                        const result = await cloudinary.uploader.upload(file[0].path, {\n                            folder: `users/${currentUser.employeeCode}/documents`,\n                            resource_type: 'auto'\n                        });\n                        updateData.legalDocuments[fieldName] = result.secure_url;\n                    } catch (uploadError) {\n                        console.error(`Error uploading ${fieldName}:`, uploadError);\n                    }\n                }\n            }\n        }\n\n        // Parse nested objects if they come as strings\n        if (typeof updateData.bankDetails === 'string') {\n            updateData.bankDetails = JSON.parse(updateData.bankDetails);\n        }\n        if (typeof updateData.emergencyContact === 'string') {\n            updateData.emergencyContact = JSON.parse(updateData.emergencyContact);\n        }\n        if (typeof updateData.reference === 'string') {\n            updateData.reference = JSON.parse(updateData.reference);\n        }\n\n        // Add audit info\n        updateData.updatedBy = req.user.id;\n\n        // Remove password field if present (use specific endpoint for password updates)\n        if (updateData.password) {\n            delete updateData.password;\n        }\n\n        const updatedUser = await User.findByIdAndUpdate(\n                req.params.id,\n                updateData, { new: true, runValidators: true }\n            )\n            .populate('branch', 'name code')\n            .populate('department', 'name code')\n            .populate('designation', 'name description')\n            .populate('employmentType', 'name code')\n            .populate('headOffice', 'name code')\n            .populate('headOffices', 'name code')\n            .populate('manager', 'name email role')\n            .populate('managers', 'name email role')\n            .populate('areaManagers', 'name email role')\n            .populate('state', 'name code')\n            .select('-password');\n\n        if (!updatedUser) {\n            return res.status(404).json({\n                success: false,\n                message: 'User not found'\n            });\n        }\n\n        res.json({\n            success: true,\n            message: 'User updated successfully',\n            data: updatedUser\n        });\n    } catch (err) {\n        console.error('Update user error:', err);\n        res.status(500).json({\n            success: false,\n            message: err.message || 'Server error'\n        });\n    }\n};\n\n/**\n * Update user profile (authenticated user can update their own profile)\n * PATCH /api/users/profile\n */\nexports.updateProfile = async(req, res) => {\n    try {\n        // Only allow updating specific fields\n        const allowedFields = ['name', 'email', 'mobileNumber', 'address', 'emergencyContact'];\n\n        const updateData = {};\n        Object.keys(req.body).forEach(key => {\n            if (allowedFields.includes(key)) {\n                updateData[key] = req.body[key];\n            }\n        });\n\n        // Add audit info\n        updateData.updatedBy = req.user.id;\n\n        const updatedUser = await User.findByIdAndUpdate(\n            req.user.id,\n            updateData, { new: true, runValidators: true }\n        ).select('-password');\n\n        if (!updatedUser) {\n            return res.status(404).json({\n                success: false,\n                message: 'User not found'\n            });\n        }\n\n        res.json({\n            success: true,\n            message: 'Profile updated successfully',\n            data: updatedUser\n        });\n    } catch (err) {\n        console.error('Profile update error:', err);\n        res.status(500).json({\n            success: false,\n            message: err.message || 'Server error'\n        });\n    }\n};\n\n/**\n * Change own password (authenticated user)\n * PATCH /api/users/change-password\n */\nexports.changePassword = async(req, res) => {\n    try {\n        const { currentPassword, newPassword } = req.body;\n\n        if (!currentPassword || !newPassword) {\n            return res.status(400).json({\n                success: false,\n                message: 'Current password and new password are required'\n            });\n        }\n\n        if (typeof newPassword !== 'string' || newPassword.length < 6) {\n            return res.status(400).json({\n                success: false,\n                message: 'New password must be at least 6 characters'\n            });\n        }\n\n        const user = await User.findById(req.user.id);\n        if (!user) {\n            return res.status(404).json({\n                success: false,\n                message: 'User not found'\n            });\n        }\n\n        // Verify current password\n        const isMatch = await user.comparePassword(currentPassword);\n        if (!isMatch) {\n            return res.status(400).json({\n                success: false,\n                message: 'Current password is incorrect'\n            });\n        }\n\n        // Hash and update password\n        const salt = await bcrypt.genSalt(10);\n        const hashedPassword = await bcrypt.hash(newPassword, salt);\n\n        user.password = hashedPassword;\n        user.updatedBy = req.user.id;\n        await user.save();\n\n        res.json({\n            success: true,\n            message: 'Password changed successfully'\n        });\n    } catch (err) {\n        console.error('Change password error:', err);\n        res.status(500).json({\n            success: false,\n            message: err.message || 'Server error'\n        });\n    }\n};\n\n/**\n * Admin: Update a user's password\n * PUT /api/users/:id/password\n */\nexports.updateUserPassword = async(req, res) => {\n    try {\n        // Only Admins or Super Admins can update others' passwords\n        if (!req.user || !['Admin', 'Super Admin'].includes(req.user.role)) {\n            return res.status(403).json({\n                success: false,\n                message: 'Access denied'\n            });\n        }\n\n        const { password } = req.body;\n        if (!password || typeof password !== 'string' || password.length < 6) {\n            return res.status(400).json({\n                success: false,\n                message: 'Password must be at least 6 characters'\n            });\n        }\n\n        const hashed = await bcrypt.hash(password, 10);\n        const updated = await User.findByIdAndUpdate(\n            req.params.id, {\n                password: hashed,\n                updatedBy: req.user.id\n            }, { new: true }\n        );\n\n        if (!updated) {\n            return res.status(404).json({\n                success: false,\n                message: 'User not found'\n            });\n        }\n\n        return res.json({\n            success: true,\n            message: 'Password updated successfully'\n        });\n    } catch (err) {\n        console.error('Update user password error:', err);\n        res.status(500).json({\n            success: false,\n            message: err.message || 'Server error'\n        });\n    }\n};\n\n/**\n * Change user status (active/inactive)\n * PATCH /api/users/:id/status\n */\nexports.changeUserStatus = async(req, res) => {\n    try {\n        // Only Admins or Super Admins can change user status\n        if (!req.user || !['Admin', 'Super Admin'].includes(req.user.role)) {\n            return res.status(403).json({\n                success: false,\n                message: 'Access denied'\n            });\n        }\n\n        const { isActive } = req.body;\n\n        if (typeof isActive !== 'boolean') {\n            return res.status(400).json({\n                success: false,\n                message: 'isActive must be a boolean value'\n            });\n        }\n\n        const updatedUser = await User.findByIdAndUpdate(\n            req.params.id, {\n                isActive,\n                updatedBy: req.user.id\n            }, { new: true }\n        ).select('-password');\n\n        if (!updatedUser) {\n            return res.status(404).json({\n                success: false,\n                message: 'User not found'\n            });\n        }\n\n        res.json({\n            success: true,\n            message: `User ${isActive ? 'activated' : 'deactivated'} successfully`,\n            data: updatedUser\n        });\n    } catch (err) {\n        console.error('Change user status error:', err);\n        res.status(500).json({\n            success: false,\n            message: err.message || 'Server error'\n        });\n    }\n};\n\n/**\n * Get user history/activity log\n * GET /api/users/:userId/history\n */\nexports.getUserHistory = async(req, res) => {\n    try {\n        const { userId } = req.params;\n\n        // Check if user exists\n        const user = await User.findById(userId).select('name email employeeCode');\n        if (!user) {\n            return res.status(404).json({\n                success: false,\n                message: 'User not found'\n            });\n        }\n\n        // For now, return basic user info and creation/update history\n        // This can be expanded to include actual activity logs if you have an audit log system\n        const history = {\n            user: user,\n            activities: [{\n                action: 'User Created',\n                timestamp: user.createdAt || new Date(),\n                details: 'User account was created'\n            }]\n        };\n\n        // If user has been updated, add update activity\n        if (user.updatedAt && user.updatedAt !== user.createdAt) {\n            history.activities.push({\n                action: 'Profile Updated',\n                timestamp: user.updatedAt,\n                details: 'User profile was updated'\n            });\n        }\n\n        res.json({\n            success: true,\n            data: history\n        });\n    } catch (err) {\n        console.error('Get user history error:', err);\n        res.status(500).json({\n            success: false,\n            message: err.message || 'Server error'\n        });\n    }\n};\n\n/**\n * Delete user by ID\n * DELETE /api/users/:id\n */\nexports.deleteUser = async(req, res) => {\n    try {\n        // Both Admin and Super Admin can delete users\n        if (!req.user || !['Admin', 'Super Admin'].includes(req.user.role)) {\n            return res.status(403).json({\n                success: false,\n                message: 'Access denied. Only Admin or Super Admin can delete users'\n            });\n        }\n\n        const deletedUser = await User.findByIdAndDelete(req.params.id);\n\n        if (!deletedUser) {\n            return res.status(404).json({\n                success: false,\n                message: 'User not found'\n            });\n        }\n\n        res.json({\n            success: true,\n            message: 'User deleted successfully'\n        });\n    } catch (err) {\n        console.error('Delete user error:', err);\n        res.status(500).json({\n            success: false,\n            message: err.message || 'Server error'\n        });\n    }\n};\n\n/**\n * Get users by state for State Head\n * GET /api/users/by-state\n */\nexports.getUsersByState = async(req, res) => {\n    try {\n        const { search, department, role, page = 1, limit = 50 } = req.query;\n        const currentUser = req.user;\n\n        // Check if the current user is a State Head\n        if (!currentUser || currentUser.role !== 'State Head') {\n            return res.status(403).json({\n                success: false,\n                message: 'Access denied. Only State Heads can access this endpoint.'\n            });\n        }\n\n        // Get the current user's state\n        const stateHeadUser = await User.findById(currentUser.id).populate('state');\n        \n        if (!stateHeadUser || !stateHeadUser.state) {\n            return res.status(400).json({\n                success: false,\n                message: 'State Head must be assigned to a state to view users.'\n            });\n        }\n\n        const stateId = stateHeadUser.state._id;\n\n        // First, find all head offices in the State Head's state\n        const HeadOffice = require('../headoffice/Model');\n        const headOfficesInState = await HeadOffice.find({ \n            state: stateId, \n            isActive: true \n        }).select('_id');\n\n        const headOfficeIds = headOfficesInState.map(ho => ho._id);\n        \n        console.log('DEBUG: State ID:', stateId);\n        console.log('DEBUG: Head offices in state:', headOfficeIds.length);\n        console.log('DEBUG: Head office IDs:', headOfficeIds.map(id => id.toString()));\n        \n        // Additional debug: Check some sample users to understand their data structure\n        const sampleUsers = await User.find({ isActive: true }).limit(5).select('name email headOffice headOffices state');\n        console.log('DEBUG: Sample users data:');\n        sampleUsers.forEach(user => {\n            console.log(`  User: ${user.name}`);\n            console.log(`    state: ${user.state || 'null'}`);\n            console.log(`    headOffice: ${user.headOffice || 'null'}`);\n            console.log(`    headOffices: ${JSON.stringify(user.headOffices || [])}`);\n        });\n\n        // Build query to find users in this state\n        // Include users who are:\n        // 1. Directly assigned to the state\n        // 2. Assigned to head offices in this state  \n        let query = {\n            isActive: true,\n            $or: [\n                // Direct state assignment\n                { state: stateId },\n                // Head office assignment (by ID)\n                { headOffice: { $in: headOfficeIds } },\n                { headOffices: { $in: headOfficeIds } }\n            ]\n        };\n        \n        console.log('DEBUG: Query:', JSON.stringify(query, null, 2));\n\n        // Add search filter if provided\n        if (search) {\n            query.$and = query.$and || [];\n            query.$and.push({\n                $or: [\n                    { name: { $regex: search, $options: 'i' } },\n                    { employeeCode: { $regex: search, $options: 'i' } },\n                    { email: { $regex: search, $options: 'i' } }\n                ]\n            });\n        }\n\n        // Add department filter if provided\n        if (department) {\n            query.department = department;\n        }\n\n        // Add role filter if provided\n        if (role) {\n            query.role = role;\n        }\n\n        // Calculate pagination\n        const skip = (page - 1) * limit;\n\n        // Execute queries in parallel for better performance\n        const [users, totalCount] = await Promise.all([\n            User.find(query)\n                .populate('department', 'name')\n                .populate('designation', 'name')\n                .populate('headOffice', 'name state')\n                .populate('headOffices', 'name state')\n                .populate('state', 'name')\n                .populate('branch', 'name')\n                .populate('employmentType', 'name')\n                .select('employeeCode name email role department headOffice headOffices state branch employmentType mobileNumber dateOfJoining salaryAmount isActive createdAt')\n                .sort({ name: 1 })\n                .skip(skip)\n                .limit(parseInt(limit)),\n            User.countDocuments(query)\n        ]);\n\n        // Format the response for frontend consumption\n        const formattedUsers = users.map(user => ({\n            id: user._id,\n            employeeCode: user.employeeCode,\n            name: user.name,\n            email: user.email,\n            role: user.role,\n            department: user.department?.name || 'Not Assigned',\n            headOffice: user.headOffice?.name || 'Not Assigned',\n            headOffices: user.headOffices?.map(ho => ho.name).join(', ') || 'Not Assigned',\n            state: user.state?.name || stateHeadUser.state.name,\n            branch: user.branch?.name || 'Not Assigned',\n            employmentType: user.employmentType?.name || 'Not Assigned',\n            mobileNumber: user.mobileNumber,\n            dateOfJoining: user.dateOfJoining,\n            salaryAmount: user.salaryAmount,\n            isActive: user.isActive,\n            createdAt: user.createdAt\n        }));\n\n        // Calculate pagination info\n        const totalPages = Math.ceil(totalCount / limit);\n        const hasNext = page < totalPages;\n        const hasPrev = page > 1;\n\n        res.json({\n            success: true,\n            data: {\n                users: formattedUsers,\n                pagination: {\n                    currentPage: parseInt(page),\n                    totalPages,\n                    totalCount,\n                    limit: parseInt(limit),\n                    hasNext,\n                    hasPrev\n                },\n                state: {\n                    id: stateId,\n                    name: stateHeadUser.state.name\n                },\n                headOfficesCount: headOfficeIds.length\n            },\n            message: `Found ${formattedUsers.length} users in ${stateHeadUser.state.name} state`\n        });\n    } catch (err) {\n        console.error('Get users by state error:', err);\n        res.status(500).json({\n            success: false,\n            message: err.message || 'Server error'\n        });\n    }\n};\n\n/**\n * Get current user's assigned head offices\n * GET /api/users/my-head-offices\n */\nexports.getMyHeadOffices = async(req, res) => {\n    try {\n        const user = await User.findById(req.user.id)\n            .populate('headOffice', 'name code')\n            .populate('headOffices', 'name code');\n\n        if (!user) {\n            return res.status(404).json({\n                success: false,\n                message: 'User not found'\n            });\n        }\n\n        // Return all assigned head offices as an array\n        let headOffices = [];\n        \n        if (user.headOffices && user.headOffices.length > 0) {\n            headOffices = user.headOffices;\n        } else if (user.headOffice) {\n            headOffices = [user.headOffice];\n        }\n\n        res.json({\n            success: true,\n            data: headOffices\n        });\n    } catch (err) {\n        console.error('Get my head offices error:', err);\n        res.status(500).json({\n            success: false,\n            message: err.message || 'Server error'\n        });\n    }\n};\n\n/**\n * Get active users for shift assignment\n * GET /api/users/for-shift-assignment\n */\nexports.getUsersForShiftAssignment = async(req, res) => {\n    try {\n        const { \n            search, \n            department, \n            role, \n            page = 1, \n            limit = 100 // Default limit of 100 users per page\n        } = req.query;\n        \n        // Build query - more inclusive for shift assignment\n        let query = {};\n        \n        // Only exclude inactive users if specifically requested\n        // By default, show all users including admins for shift assignment\n        const { includeInactive = 'false', excludeAdmins = 'false' } = req.query;\n        \n        if (includeInactive !== 'true') {\n            query.isActive = true;\n        }\n        \n        if (excludeAdmins === 'true') {\n            query.role = { $nin: ['Super Admin', 'Admin'] };\n        }\n\n        // Add search filter if provided\n        if (search) {\n            query.$or = [\n                { name: { $regex: search, $options: 'i' } },\n                { employeeCode: { $regex: search, $options: 'i' } },\n                { email: { $regex: search, $options: 'i' } }\n            ];\n        }\n\n        // Add department filter if provided\n        if (department) {\n            query.department = department;\n        }\n\n        // Add role filter if provided\n        if (role) {\n            query.role = role;\n        }\n\n        // Debug: Log the final query\n        console.log('Shift assignment query:', JSON.stringify(query, null, 2));\n        console.log('Query parameters:', { search, department, role, page, limit, includeInactive, excludeAdmins });\n\n        // Calculate pagination\n        const skip = (parseInt(page) - 1) * parseInt(limit);\n\n        // Execute queries in parallel for better performance\n        const [users, totalCount] = await Promise.all([\n            User.find(query)\n                .populate('department', 'name')\n                .populate('designation', 'name')\n                .populate('headOffice', 'name')\n                .populate('headOffices', 'name')\n                .populate('state', 'name')\n                .select('employeeCode name email role department headOffice headOffices state mobileNumber dateOfJoining isActive')\n                .sort({ name: 1 }) // Sort by name alphabetically\n                .skip(skip)\n                .limit(parseInt(limit)),\n            User.countDocuments(query)\n        ]);\n\n        // Format the response for frontend consumption\n        const formattedUsers = users.map(user => ({\n            id: user._id,\n            employeeCode: user.employeeCode,\n            name: user.name,\n            email: user.email,\n            role: user.role,\n            department: user.department?.name || 'Not Assigned',\n            headOffice: user.headOffice?.name || 'Not Assigned',\n            state: user.state?.name || 'Not Assigned',\n            mobileNumber: user.mobileNumber,\n            dateOfJoining: user.dateOfJoining,\n            isActive: user.isActive\n        }));\n\n        // Calculate pagination info\n        const totalPages = Math.ceil(totalCount / parseInt(limit));\n        const hasNext = parseInt(page) < totalPages;\n        const hasPrev = parseInt(page) > 1;\n\n        res.json({\n            success: true,\n            count: formattedUsers.length,\n            totalCount,\n            data: formattedUsers,\n            pagination: {\n                currentPage: parseInt(page),\n                totalPages,\n                totalCount,\n                limit: parseInt(limit),\n                hasNext,\n                hasPrev\n            }\n        });\n    } catch (err) {\n        console.error('Get users for shift assignment error:', err);\n        res.status(500).json({\n            success: false,\n            message: err.message || 'Server error'\n        });\n    }\n};"
        }
    ]
}